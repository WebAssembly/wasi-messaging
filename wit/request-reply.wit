/// The request-reply interface allows a guest to send a message and await a response. This
/// interface is considered optional as not all message services support the concept of
/// request/reply. However, request/reply is a very common pattern in messaging and as such, we have
/// included it as a core interface.
interface request-reply {
    use types.{client, message, error};

    /// Options for a request/reply operation. This is a resource to allow for future expansion of
    /// options.
    resource request-options {
        /// Creates a new request options resource with no options set.
        constructor();

        /// The maximum amount of time to wait for a response. If the timeout value is not set, then
        /// the request/reply operation will block until a message is received in response.
        set-timeout-ms: func(timeout-ms: u32);

        /// The maximum number of replies to expect before returning. This only applies to
        /// `request-multi` and is ignored otherwise. If the number of replies is not set and
        /// timeout isn't set, then the operation will block until a message is received in
        /// response (essentially the same behavior as `request`).
        set-expected-replies: func(expected-replies: u32);
    }

    /// Performs a blocking request/reply operation with an optional set of request options. This
    /// returns only the first reply received or a timeout . If more than one reply is expected, then the
    /// `request-multi` function should be used instead.
    request: func(c: borrow<client>, msg: message, opts: option<request-options>) -> result<message, error>;

    /// Performs a blocking request/reply operation with an optional set of request options. This
    /// returns all replies received up until timeout or the configured set of expected replies. It
    /// is recommended to use a `request-options` with the timeout set to ensure that the operation
    /// does not block indefinitely. Unlike request, this function should not return an error on
    /// timeout and should instead return all of the replies received up to that point. This is to
    /// faciliate use in scatter/gather operations where the number of expected replies is not
    /// known.
    request-multi: func(c: borrow<client>, msg: message, opts: option<request-options>) -> result<list<message>, error>;

    /// Replies to the given message with the given response message. The details of which channel 
    /// the message is sent to is up to the implementation. This allows for reply to details to be
    /// handled in the best way possible for the underlying messaging system.
    reply: func(reply-to: borrow<message>, reply: message) -> result<_, error>;
}