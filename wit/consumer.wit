/// The consumer interface allows a guest to dynamically update its subscriptions and configuration
/// as well as functionality for completing (acking) or abandoning (nacking) messages.
interface consumer {
    use types.{client, message, channel, error, guest-configuration};

    /// 'Fit-all' type function for updating a guest's configuration â€“ this could be useful for:
    ///     - unsubscribing from a channel,
    ///     - checkpointing,
    ///     - etc..
    /// 
    /// Please note that implementations that provide `wasi:messaging` are responsible for ensuring
    /// that guests are not allowed to subscribe to channels that they are not configured to
    /// subscribe to (or have access to). Failure to do so can result in possible breakout or access
    /// to resources that are not intended to be accessible to the guest. This means implementations
    /// should validate that the configured topics are valid topics the guest should have access to or 
    /// enforce it via the credentials used to connect to the service.
    update-guest-configuration: func(gc: guest-configuration) -> result<_, error>;

    /// A message can exist under several statuses:
    /// (1) available: the message is ready to be read,
    /// (2) acquired: the message has been sent to a consumer (but still exists in the queue),
    /// (3) accepted (result of complete-message): the message has been received and ACK-ed by a consumer and can be safely removed from the queue,
    /// (4) rejected (result of abandon-message): the message has been received and NACK-ed by a consumer, at which point it can be:
    ///         - deleted,
    ///         - sent to a dead-letter queue, or
    ///         - kept in the queue for further processing.
    complete-message: func(m: message) -> result<_, error>;
    abandon-message: func(m: message) -> result<_, error>;
}
